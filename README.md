# Readme

This project is an example of how to create a cross-platform Arma extension in Rust. 
The extension has no dependencies except on the core Rust libraries, and builds into a single .dll.

The extension will run on Linux and Windows, both 32-bit and 64-bit.

It supports:
* RVExtensionVersion
* RVExtension
* RVExtensionArgs
* RVExtensionRegisterCallback

## Motivation

Rust is a memory-safe, fast language that, while it has a bit of a learning curve, is much less prone to weird bugs in production than C and C++ (in my opinion).
It has the added advantage that its standard library is cross-platform, so it's possible to easily build Windows and Linux compatible extensions - particularly when utilising things such as file access and networking.

## Installation

You'll need a rust toolchain on your platform of choice (this is left as an exercise for the reader).

Clone this package, then execute `cargo build`, to build the library as appropriate for your platform.

## 32-bit Windows Compilation

To cross-compile a 32-bit Windows library on 64-bit windows, use `cargo build --target=i686-pc-windows-msvc`. 
Only the MSVC toolchain is supported for 32-bit Windows compilation, due to the nature of the hacks needed to make it work (see .cargo/config for specifics).

Broadly speaking, Windows uses "stdcall" calling conventions to call functions in the DLL. In 32-bit Windows, the symbol names for these functions are 'decorated', meaning they look something like this: `_RVExtension@12`. The @12 being the number of bytes of parameters the functions take.

As it happens, in the rust compiler's infinite wisdom, it generates a '.def' file for the MSVC toolchain linker, that describes the exported symbols. Unfortunately for us, there's no way to make it export the decorated functions (that I've been able to find).

Instead, we override the .def generated by Rust with our own file `Win32.def`, which exports the symbols with the correct names.

This means we don't transitively export any dependencies that our Rust code imports, which is a bit of a shame, but it doesn't seem to break anything.
This also is why the GCC toolchain is Windows is *not* supported. If someone wants to explore that possibility, feel free!

## Alternatives

This is meant more as an example piece of code, than something to be used in production (though it's entirely possible to use this in production).

As such, it isn't a particularly *nice* interface between Arma and Rust - it's pretty much the bare minimum to create a safe implementation.

Synixebrett has created a much more fully-featured Rust-Arma interface using some rather fancy Rust macros. If you're looking for something that hides away most of the implementation for you, it's probably worth checking out: https://github.com/synixebrett/arma-rs

